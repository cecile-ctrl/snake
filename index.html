<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Snake in Real Life</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: sans-serif;
    }

    #startScreen, #gameOverScreen {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      width: 100%;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      flex-direction: column;
      color: white;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 999;
    }

    #startScreen h1, #gameOverScreen h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }

    button {
      padding: 12px 24px;
      font-size: 18px;
      background: #fff;
      color: #2E7D32;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
    }

    button:hover {
      background: #f0f0f0;
    }

    #map { height: 100vh; display: none; }

    /* ✅ HUD rechtsonder */
    #hud {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: white;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      font-size: 16px;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }

    /* 🔵 Blauwe pin zoals Google Maps */
    .blue-pin {
      width: 24px;
      height: 24px;
      border-radius: 50% 50% 50% 0;
      background: #4285F4;
      position: absolute;
      transform: rotate(-45deg);
      left: 50%;
      top: 50%;
      margin: -12px 0 0 -12px;
      border: 2px solid white;
    }
    .blue-pin::after {
      content: "";
      width: 8px;
      height: 8px;
      margin: 7px 0 0 7px;
      background: white;
      position: absolute;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <!-- Startscherm -->
  <div id="startScreen">
    <h1>Snake in Real Life</h1>
    <button id="startBtn">Start spel</button>
  </div>

  <!-- Game Over scherm -->
  <div id="gameOverScreen" style="display:none;">
    <h1>Game Over!</h1>
    <p id="finalScore">Score: 0</p>
    <p id="finalDistance">Afstand: 0 m</p>
    <button id="restartBtn">Opnieuw starten</button>
  </div>

  <!-- Spel -->
  <div id="map"></div>
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="distance">Afstand: 0 m</div>
    <div id="highscore">Highscore: 0</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let map, pathCoords, pathLine, foodMarker, foodCoords, roads, center, score, maxPathLength;
    let playerMarker = null;
    let playerCircle = null;
    let highscore = localStorage.getItem("highscore") || 0;
    const stepTime = 5000;
    let gameInterval = null;
    const minDistanceBeforeGameOver = 100; // ✅ pas na 100m kan je verliezen

    function resetGame() {
      pathCoords = [];
      pathLine = null;
      foodMarker = null;
      foodCoords = null;
      roads = [];
      center = null;
      score = 0;
      maxPathLength = 500;
      updateHUD();
    }

    // ---- HUD bijwerken ----
    function updateHUD() {
      document.getElementById("score").innerText = "Score: " + score;
      document.getElementById("distance").innerText = "Afstand: " + Math.round(getPathLength(pathCoords)) + " m";
      document.getElementById("highscore").innerText = "Highscore: " + highscore;
    }

    // ---- Wegen laden ----
    async function loadRoads(center, radius=500) {
      const query = `
        [out:json];
        way["highway"]["highway"!="motorway"]["highway"!="trunk"]["access"!="private"]["access"!="no"]
          (around:${radius},${center[0]},${center[1]});
        out geom;
      `;
      const url = "https://overpass.kumi.systems/api/interpreter?data=" + encodeURIComponent(query);
      try {
        const res = await fetch(url);
        const data = await res.json();
        roads = data.elements;
      } catch (err) {
        console.warn("Kon geen wegen laden:", err);
        roads = [];
      }
    }

    // ---- Willekeurig punt op weg, binnen 500m ----
    function randomPointOnRoad(maxRadius = 500) {
      if (roads.length === 0) return null;

      for (let tries = 0; tries < 50; tries++) { // probeer max 50 keer iets te vinden
        const road = roads[Math.floor(Math.random() * roads.length)];
        const nodes = road.geometry;
        if (nodes.length < 2) continue;

        const idx = Math.floor(Math.random() * (nodes.length - 1));
        const a = nodes[idx], b = nodes[idx+1];
        const t = Math.random();
        const point = [a.lat + t * (b.lat - a.lat), a.lon + t * (b.lon - a.lon)];

        // check afstand tot startpositie
        if (center) {
          const d = getDistance(center[0], center[1], point[0], point[1]);
          if (d <= maxRadius) {
            return point; // ✅ geldig punt gevonden
          }
        }
      }
      return null; // geen geldig punt
    }

    function generateFood() {
      const point = randomPointOnRoad(500); // max 500m
      if (!point) return;

      if (foodMarker) map.removeLayer(foodMarker);

      const appleIcon = L.divIcon({
        html: "🍎",
        className: "",
        iconSize: [24, 24]
      });

      foodMarker = L.marker(point, { icon: appleIcon }).addTo(map);
      foodCoords = point;

      // 📌 Klik op appel → toon afstand tot speler
      foodMarker.on("click", () => {
        if (!pathCoords.length) {
          foodMarker.bindPopup("Nog geen locatie bekend!").openPopup();
          return;
        }
        const me = pathCoords[pathCoords.length - 1];
        const d = getDistance(me[0], me[1], foodCoords[0], foodCoords[1]);
        foodMarker.bindPopup(`Afstand: ${(d/1000).toFixed(2)} km`).openPopup();
      });
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
      const Δφ = (lat2-lat1) * Math.PI/180;
      const Δλ = (lon2-lon1) * Math.PI/180;
      const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));
    }

    function getPathLength(coords) {
      let length = 0;
      for (let i = 1; i < coords.length; i++) {
        length += getDistance(coords[i-1][0], coords[i-1][1], coords[i][0], coords[i][1]);
      }
      return length;
    }

    function trimPath() {
      let length = getPathLength(pathCoords);
      while (length > maxPathLength && pathCoords.length > 1) {
        pathCoords.shift();
        length = getPathLength(pathCoords);
      }
    }

    function intersectsPath(newPoint) {
      if (pathCoords.length < 2) return false;
      for (let i = 0; i < pathCoords.length - 2; i++) {
        if (pathCoords[i][0] === newPoint[0] && pathCoords[i][1] === newPoint[1]) {
          return true;
        }
      }
      return false;
    }

    function gameOver() {
      clearInterval(gameInterval);

      // ✅ Highscore check
      if (score > highscore) {
        highscore = score;
        localStorage.setItem("highscore", highscore);
      }

      document.getElementById("finalScore").innerText = "Score: " + score;
      document.getElementById("finalDistance").innerText = "Afstand: " + Math.round(getPathLength(pathCoords)) + " m";
      document.getElementById("gameOverScreen").style.display = "flex";
    }

    function trackLocation() {
      navigator.geolocation.getCurrentPosition(async pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        const newPoint = [latitude, longitude];

        if (!center) {
          center = newPoint;
          await loadRoads(center, 2000);
          generateFood();
        }

        if (playerMarker) map.removeLayer(playerMarker);
        if (playerCircle) map.removeLayer(playerCircle);

        const bluePinIcon = L.divIcon({ className: "blue-pin", iconSize: [24, 24] });
        playerMarker = L.marker(newPoint, { icon: bluePinIcon }).addTo(map);
        playerCircle = L.circle(newPoint, { radius: accuracy, color: "blue", opacity: 0.3 }).addTo(map);

        if (!intersectsPath(newPoint)) {
          pathCoords.push(newPoint);
          trimPath();

          if (pathLine) map.removeLayer(pathLine);
          pathLine = L.polyline(pathCoords, { color: 'green' }).addTo(map);
          map.setView(newPoint, 17);

          if (foodCoords) {
            const d = getDistance(latitude, longitude, foodCoords[0], foodCoords[1]);
            if (d < 10) {
              score++;
              if (score > highscore) {
                highscore = score;
                localStorage.setItem("highscore", highscore);
              }
              maxPathLength += 500;
              generateFood();
            }
          }
        } else {
          if (getPathLength(pathCoords) > minDistanceBeforeGameOver) {
            gameOver();
          }
        }

        updateHUD();
      }, err => {
        console.error("GPS fout:", err);
      });
    }

    document.getElementById("startBtn").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("map").style.display = "block";
      document.getElementById("hud").style.display = "block";

      map = L.map('map').setView([52.3702, 4.8952], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

      resetGame();
      updateHUD();
      gameInterval = setInterval(trackLocation, stepTime);
    });

    document.getElementById("restartBtn").addEventListener("click", () => {
      document.getElementById("gameOverScreen").style.display = "none";
      resetGame();
      if (map) {
        map.eachLayer(layer => { 
          if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.Circle) map.removeLayer(layer); 
        });
      }
      updateHUD();
      gameInterval = setInterval(trackLocation, stepTime);
    });
  </script>
</body>
</html>






