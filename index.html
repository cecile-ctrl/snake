<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Snake in Real Life</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: sans-serif;
    }

    #startScreen, #gameOverScreen {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      width: 100%;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      flex-direction: column;
      color: white;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 999;
    }

    #startScreen h1, #gameOverScreen h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }

    button {
      padding: 12px 24px;
      font-size: 18px;
      background: #fff;
      color: #2E7D32;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
    }

    button:hover {
      background: #f0f0f0;
    }

    #map { height: 100vh; display: none; }

    /* âœ… HUD rechtsonder */
    #hud {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: white;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      font-size: 16px;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }

    /* ðŸ”µ Blauwe pin zoals Google Maps */
    .blue-pin {
      width: 24px;
      height: 24px;
      border-radius: 50% 50% 50% 0;
      background: #4285F4;
      position: absolute;
      transform: rotate(-45deg);
      left: 50%;
      top: 50%;
      margin: -12px 0 0 -12px;
      border: 2px solid white;
    }
    .blue-pin::after {
      content: "";
      width: 8px;
      height: 8px;
      margin: 7px 0 0 7px;
      background: white;
      position: absolute;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <!-- Startscherm -->
  <div id="startScreen">
    <h1>Snake in Real Life</h1>
    <button id="startBtn">Start spel</button>
  </div>

  <!-- Game Over scherm -->
  <div id="gameOverScreen" style="display:none;">
    <h1>Game Over!</h1>
    <p id="finalScore">Score: 0</p>
    <p id="finalDistance">Afstand: 0 m</p>
    <button id="restartBtn">Opnieuw starten</button>
  </div>

  <!-- Spel -->
  <div id="map"></div>
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="distance">Afstand: 0 m</div>
    <div id="highscore">Highscore: 0</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let map, pathCoords, rawPathCoords, pathLine, foodMarker, foodCoords, roads, center, score, maxPathLength;
    let playerMarker = null;
    let playerCircle = null;
    let highscore = localStorage.getItem("highscore") || 0;
    const stepTime = 5000;
    let gameInterval = null;
    const minDistanceBeforeGameOver = 100; // âœ… pas na 100m kan je verliezen

    // Smoothing parameters
    let smoothingFactor = 0.3;
    let minDistance = 3; // meters
    let lastSmoothedPoint = null;

    function resetGame() {
      pathCoords = [];
      rawPathCoords = [];
      pathLine = null;
      foodMarker = null;
      foodCoords = null;
      roads = [];
      center = null;
      score = 0;
      maxPathLength = 500;
      updateHUD();
    }

    // ---- HUD bijwerken ----
    function updateHUD() {
      document.getElementById("score").innerText = "Score: " + score;
      document.getElementById("distance").innerText = "Afstand: " + Math.round(getPathLength(pathCoords)) + " m";
      document.getElementById("highscore").innerText = "Highscore: " + highscore;
    }

    // Kalman-like filter for GPS smoothing
    function kalmanFilter(coords, factor = 0.3) {
      if (coords.length < 2) return coords;

      const filtered = [coords[0]];

      for (let i = 1; i < coords.length; i++) {
        const prev = filtered[i - 1];
        const curr = coords[i];

        // Simple Kalman-like smoothing
        const smoothed = [
          prev[0] + factor * (curr[0] - prev[0]),
          prev[1] + factor * (curr[1] - prev[1])
        ];

        filtered.push(smoothed);
      }

      return filtered;
    }

    // Bezier curve smoothing
    function bezierSmooth(coords) {
      if (coords.length < 3) return coords;

      const smoothed = [];

      for (let i = 0; i < coords.length - 2; i++) {
        const p0 = coords[i];
        const p1 = coords[i + 1];
        const p2 = coords[i + 2];

        // Add original point
        smoothed.push(p1);

        // Add bezier interpolated points
        for (let t = 0.2; t <= 0.8; t += 0.2) {
          const x = (1 - t) * (1 - t) * p0[0] + 2 * (1 - t) * t * p1[0] + t * t * p2[0];
          const y = (1 - t) * (1 - t) * p0[1] + 2 * (1 - t) * t * p1[1] + t * t * p2[1];
          smoothed.push([x, y]);
        }
      }

      // Add last point
      if (coords.length > 0) {
        smoothed.push(coords[coords.length - 1]);
      }

      return smoothed;
    }

    // Moving average smoothing
    function movingAverageSmooth(coords, windowSize = 3) {
      if (coords.length < windowSize) return coords;

      const smoothed = [];

      for (let i = 0; i < coords.length; i++) {
        const start = Math.max(0, i - Math.floor(windowSize / 2));
        const end = Math.min(coords.length, start + windowSize);

        let sumLat = 0, sumLon = 0;
        let count = 0;

        for (let j = start; j < end; j++) {
          sumLat += coords[j][0];
          sumLon += coords[j][1];
          count++;
        }

        smoothed.push([sumLat / count, sumLon / count]);
      }

      return smoothed;
    }

    // Remove points that are too close together
    function decimatePoints(coords, minDist = 3) {
      if (coords.length < 2) return coords;

      const filtered = [coords[0]];

      for (let i = 1; i < coords.length; i++) {
        const last = filtered[filtered.length - 1];
        const dist = getDistance(last[0], last[1], coords[i][0], coords[i][1]);

        if (dist >= minDist) {
          filtered.push(coords[i]);
        }
      }

      return filtered;
    }

    // Combined smoothing function
    function smoothPath(coords) {
      if (coords.length < 2) return coords;

      // Step 1: Remove points too close together
      let smoothed = decimatePoints(coords, minDistance);

      // Step 2: Apply Kalman-like filter
      smoothed = kalmanFilter(smoothed, smoothingFactor);

      // Step 3: Apply moving average for final smoothing
      smoothed = movingAverageSmooth(smoothed, 3);

      return smoothed;
    }

    // ---- Wegen laden ----
    async function loadRoads(center, radius=500) {
      const query = `
        [out:json];
        way["highway"]["highway"!="motorway"]["highway"!="trunk"]["access"!="private"]["access"!="no"]
          (around:${radius},${center[0]},${center[1]});
        out geom;
      `;
      const url = "https://overpass.kumi.systems/api/interpreter?data=" + encodeURIComponent(query);
      try {
        const res = await fetch(url);
        const data = await res.json();
        roads = data.elements;
      } catch (err) {
        console.warn("Kon geen wegen laden:", err);
        roads = [];
      }
    }

    // ---- Willekeurig punt op weg, binnen 500m ----
    function randomPointOnRoad(maxRadius = 500) {
      if (roads.length === 0) return null;

      for (let tries = 0; tries < 50; tries++) { // probeer max 50 keer iets te vinden
        const road = roads[Math.floor(Math.random() * roads.length)];
        const nodes = road.geometry;
        if (nodes.length < 2) continue;

        const idx = Math.floor(Math.random() * (nodes.length - 1));
        const a = nodes[idx], b = nodes[idx+1];
        const t = Math.random();
        const point = [a.lat + t * (b.lat - a.lat), a.lon + t * (b.lon - a.lon)];

        // check afstand tot startpositie
        if (center) {
          const d = getDistance(center[0], center[1], point[0], point[1]);
          if (d <= maxRadius) {
            return point; // âœ… geldig punt gevonden
          }
        }
      }
      return null; // geen geldig punt
    }

    function generateFood() {
      const point = randomPointOnRoad(500); // max 500m
      if (!point) return;

      if (foodMarker) map.removeLayer(foodMarker);

      const appleIcon = L.divIcon({
        html: "ðŸŽ",
        className: "",
        iconSize: [24, 24]
      });

      foodMarker = L.marker(point, { icon: appleIcon }).addTo(map);
      foodCoords = point;

      // ðŸ“Œ Klik op appel â†’ toon afstand tot speler
      foodMarker.on("click", () => {
        if (!pathCoords.length) {
          foodMarker.bindPopup("Nog geen locatie bekend!").openPopup();
          return;
        }
        const me = pathCoords[pathCoords.length - 1];
        const d = getDistance(me[0], me[1], foodCoords[0], foodCoords[1]);
        foodMarker.bindPopup(`Afstand: ${(d/1000).toFixed(2)} km`).openPopup();
      });
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const Ï†1 = lat1 * Math.PI/180, Ï†2 = lat2 * Math.PI/180;
      const Î”Ï† = (lat2-lat1) * Math.PI/180;
      const Î”Î» = (lon2-lon1) * Math.PI/180;
      const a = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));
    }

    function getPathLength(coords) {
      let length = 0;
      for (let i = 1; i < coords.length; i++) {
        length += getDistance(coords[i-1][0], coords[i-1][1], coords[i][0], coords[i][1]);
      }
      return length;
    }

    function trimPath() {
      let length = getPathLength(pathCoords);
      while (length > maxPathLength && pathCoords.length > 1) {
        pathCoords.shift();
        length = getPathLength(pathCoords);
      }
    }

    function intersectsPath(newPoint) {
      if (pathCoords.length < 2) return false;
      for (let i = 0; i < pathCoords.length - 2; i++) {
        if (pathCoords[i][0] === newPoint[0] && pathCoords[i][1] === newPoint[1]) {
          return true;
        }
      }
      return false;
    }

    function gameOver() {
      clearInterval(gameInterval);

      // âœ… Highscore check
      if (score > highscore) {
        highscore = score;
        localStorage.setItem("highscore", highscore);
      }

      document.getElementById("finalScore").innerText = "Score: " + score;
      document.getElementById("finalDistance").innerText = "Afstand: " + Math.round(getPathLength(pathCoords)) + " m";
      document.getElementById("gameOverScreen").style.display = "flex";
    }

    function updatePath() {
      pathCoords = smoothPath(rawPathCoords);

      if (pathLine) map.removeLayer(pathLine);
      pathLine = L.polyline(pathCoords, {
        color: 'green',
        weight: 4,
        smoothFactor: 1.0 // Leaflet's built-in smoothing
      }).addTo(map);
    }

    function trackLocation() {
      navigator.geolocation.getCurrentPosition(async pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        const newPoint = [latitude, longitude];

        if (!center) {
          center = newPoint;
          await loadRoads(center, 2000);
          generateFood();
        }

        if (playerMarker) map.removeLayer(playerMarker);
        if (playerCircle) map.removeLayer(playerCircle);

        const bluePinIcon = L.divIcon({ className: "blue-pin", iconSize: [24, 24] });
        playerMarker = L.marker(newPoint, { icon: bluePinIcon }).addTo(map);
        playerCircle = L.circle(newPoint, { radius: accuracy, color: "blue", opacity: 0.3 }).addTo(map);

        rawPathCoords.push(newPoint);
        const tempSmoothed = smoothPath(rawPathCoords);
        const smoothedNewPoint = tempSmoothed[tempSmoothed.length - 1];

        if (!intersectsPath(smoothedNewPoint)) {
          pathCoords = smoothedNewPoint;
          trimPath();
          updatePath();
          map.setView(newPoint, 17);

          if (foodCoords) {
            const d = getDistance(latitude, longitude, foodCoords[0], foodCoords[1]);
            if (d < 10) {
              score++;
              if (score > highscore) {
                highscore = score;
                localStorage.setItem("highscore", highscore);
              }
              maxPathLength += 500;
              generateFood();
            }
          }
        } else {
          if (getPathLength(pathCoords) > minDistanceBeforeGameOver) {
            gameOver();
          }
        }

        updateHUD();
      }, err => {
        console.error("GPS fout:", err);
      });
    }

    document.getElementById("startBtn").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("map").style.display = "block";
      document.getElementById("hud").style.display = "block";

      map = L.map('map').setView([52.3702, 4.8952], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

      resetGame();
      updateHUD();
      gameInterval = setInterval(trackLocation, stepTime);
    });

    document.getElementById("restartBtn").addEventListener("click", () => {
      document.getElementById("gameOverScreen").style.display = "none";
      resetGame();
      if (map) {
        map.eachLayer(layer => {
          if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.Circle) map.removeLayer(layer);
        });
      }
      updateHUD();
      gameInterval = setInterval(trackLocation, stepTime);
    });
  </script>
</body>
</html>






